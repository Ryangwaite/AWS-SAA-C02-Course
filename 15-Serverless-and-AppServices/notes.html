<h2>Serverless and AppServices</h2>
<h3>Architecture Evolution</h3>
<p>Youtube</p>
<p>Once a video is uploaded to Youtube, it creates different versions in
different quality levels. Historically the most popular way to make this work
was a monolithic architecture.</p>
<h4>Monolithic</h4>
<ul>
<li>It fails together. One error will bring the whole system down.</li>
<li>Scales together. Everything expects to be running on the same compute hardware</li>
<li>Bill together. All components are always running and always incurring charges.</li>
</ul>
<p>This is the least cost effective way to architect systems.</p>
<h4>Tiered</h4>
<p>The different components can be on the same server or different servers.</p>
<p>The components are coupled together because the endpoints connect together.</p>
<p>You can increase the size of the server that is running each application tier.</p>
<p>We can utilize load balancers in between tiers to add capacity.</p>
<p>The tiers are still coupled, the upload tier <strong>expects</strong> and requires
processing to respond. If the Processing fails completely, the upload tier
will fail because it does not recieve a response.</p>
<p>If there is a backload in one tier, it will impact the other tiers and the
customer experience.</p>
<p>Even if there is no job to be processed, the middle tier will need to be
running because otherwise it would fail.</p>
<h4>Evolving with Queues</h4>
<p>This is a system that accepts messages off a queue. Often times
they are <strong>FIFO</strong> (first in, first out)</p>
<p>Instead of passing data into the processing tier. It will store this in an S3
bucket as well as detailing the information into the queue. This now
moves towards the next slot in the queue.</p>
<p>The upload tier doesn't expect an immediate answer from the processing tier.</p>
<p>It sends an asycn message. While this is happening, the upload can add more
messages to the queue.</p>
<p>The queue will have an autoscaling group to increase capacity at the end and
process appropriately.</p>
<p>The queue has the location of the S3 bucket as well as the location
of the information.</p>
<p>The autoscaling group will only bring up servers as their needed.</p>
<h4>Event Driven Architecture</h4>
<p>Event producers - interact with customers or systems monitoring components.
They produce events in reaction to something.</p>
<p>Event consumers - pieces of software waiting for events to occur.</p>
<p>Services can be producers and consumers at once.</p>
<p>In either case, there are no resources waiting around to be used.</p>
<p>Event router is needed for event driven architecture that also manages
an event bus.</p>
<h4>Highlights</h4>
<ul>
<li>No constant running or waiting for things</li>
<li>Producer generate events when something happens</li>
<li>Clicks, events, errors, actions</li>
<li>Events are delivered to consumers of events</li>
<li>Actions are taken and the system returns to waiting</li>
</ul>
<p>Mature event driven architecture only consumes resources while handling
events.</p>
<h3>AWS Lambda</h3>
<ul>
<li>Function-as-a-service (FaaS)</li>
<li>Event driven invocation (execution)</li>
<li><strong>Lambda function</strong> piece of code in one language</li>
<li>Lambda functions use a <strong>runtime</strong> (e.g. Python 3.6)</li>
<li>Runs in a <strong>runtime environment</strong></li>
<li>You are billed only for the duration a function runs. There is no charge
for having lambda functions waiting and ready to go.</li>
</ul>
<h4>Lambda Architecture</h4>
<p>Best practice is to make it very small and very specialized.
The runtime enviroment will match the language the script is written in.
The runtime enviroment is lime a mini container provided with resources.</p>
<p>Lambda functions can be given an IAM role, <strong>execution role</strong>. Whenever that
function executes, the code inside has access to permissions.</p>
<p>This can be <strong>event-driven</strong> or <strong>manual</strong> invocation many ways.</p>
<p>Each time you invoke a lambda function, the enviroment is new and clean</p>
<p>These are by default public services and can access any websites. By default
they cannot access private VPC resources.</p>
<p>Once they are configured, they can only access resources within a VPC.</p>
<p>Should always use AWS services for input and output.</p>
<p>Lambda functions can run up to 15 minutes. That is the max limit.</p>
<h4>Key Considerations</h4>
<ul>
<li>Currently 15 min execution limit</li>
<li>Assume each execution gets a new runtime environment</li>
<li>Use the execution role which is assumed when needed</li>
<li>Always load data from other services from public API's or S3</li>
<li>Store data to other services (e.g. S3)</li>
<li>1M free requests and 400,000 GB-seconds of compute per month</li>
</ul>
<h3>CloudWatch Events and EventBridge</h3>
<p>Delivers near real time stream of system events that describe changes in AWS
products and services. EventsBridge will replace CW Events.</p>
<p>EventsBridge can also handle events from third parties. Both share the same
underlying architecture. AWS is now encouraging a migration to EB.</p>
<h4>Key Concepts</h4>
<p>They can observe if X happens at Y time(s), do Z. This is basically
CW Events V2.</p>
<p>Both systems have a default Event bus for a particular AWS account.</p>
<p>In CW Events, there is only one bus (implicit), this is not exposed.
EventBridge can have additional event buses. These can be interacted with
in the same way as the default bus.</p>
<p>Rules match incoming events or schedules. The rule matches an event and routes
that event to one or more targets as you define on that rule.</p>
<p>Architecturally at the heart of event bridge is the default event bus.</p>
<p>The default event bus is moving packets of JSON data.</p>
<h3>API Gateway</h3>
<p>Application Programming Interface (API)</p>
<p>This is a way that applications or services can communicate with each other.</p>
<p>Endpoints are used to access services. Each service has its own endpoint
in its own region.</p>
<p>When you request AWS stops an EC2 instance, the message is set to the API
in that region for that resource.</p>
<p>APIs also perform authentication using passwords or keys. API authorizes
each service and needs your permissions verified each time.</p>
<h4>Authentication</h4>
<h4>Authorization</h4>
<p>API gateway is an AWS managed service that provides managed API endpoints.
Allows you to create, publish, monitor, and secure APIs as a service.</p>
<p>Billed based on the number of API calls as well as data transfered.</p>
<p>This can be used for serverless architecture to provide an entry point
for that design.</p>
<p>This is great during an architecture evolution.</p>
<p>Step 1:
Create a managed API and point at the existing monolithic application.</p>
<p>Step 2:
Using API gateway allows the buisness to evolve along the way slowly.
This might move some of the data to fargate and aurora architecture.</p>
<p>Step 3:
Move to a full serverless architecture with DynamoDB</p>
<h3>Serverless</h3>
<p>This is not one single thing, you manage few if any servers.
Applications are a collection of small and specialized functions.</p>
<p>These functions are stateless and run in ephemeral environments.
Each time they run, they obtain the data they need each time.</p>
<p>Generally, everything is event driven. While not being used, there should
be little to no cost due to compute not being used.</p>
<p>Should use managed services when possible.</p>
<h4>Example of Serverless</h4>
<p>She browses to a static website that is running the uploader. The JS runs
directly from the web browser.</p>
<p>We use a third party auth provider, google in this case. Authenticate via
<strong>token</strong>.</p>
<p>AWS cannot use tokens provided by third parties. In this case another
service <strong>Cognito</strong> is called. This swaps the third party token for AWS
credentials.</p>
<p>It uses these temporary credentials to upload a video to S3 bucket.</p>
<p>The bucket will generate an event once it has completed the upload.</p>
<p>The event will trigger a lambda to transcode the video as needed. The
transcoder will get the original S3 bucket video location and will use
this for its workload.</p>
<p>These will be added to a new transcode bucket and will put an entry into
DynamoDB.</p>
<p>The user can then interact with another Lambda which will allow her to
pull the media from the transcode bucket using the dynamoDB entry.</p>
<h3>Simple Notification Service (SNS)</h3>
<p>HA, Durable, and Secure service.</p>
<p>This is a public service which needs access to the public endpoint. This
allows anyone from the public internet to access it.</p>
<p>Messages are under 256KB in size.</p>
<p>SNS topics are the base entity of SNS.</p>
<p>A publisher sends messages to a topic. Topics have subscribers which recieve
messages.</p>
<p>You can create topics inside the SNS.</p>
<p>By default all topics will recieve the message, you can put filters on
those lines to make sure they don't trigger additional lambdas.</p>
<p>You can use fanout to process different flows from SQS</p>
<p>Offers:</p>
<ul>
<li>Delivery Status including HTTP, Lambda, SQS</li>
<li>Delivery retries - Reliable Delivery</li>
<li>HA and Scalable (Regional)</li>
<li>SSE (server side encryption)</li>
<li>Topics can be used cross-account via Topic Policy</li>
</ul>
<h3>AWS Step Functions</h3>
<p>There are many problems with lambdas limitations that can be solved with
a state machine.</p>
<p>This is a serverless workflow</p>
<ul>
<li>Start</li>
<li>States</li>
<li>End</li>
</ul>
<p>States are <strong>things</strong> which occur</p>
<p>Maximum duration is 1 year</p>
<p>Standard workflow and express. At a high level, standard is the default
and has a 1 year workflow. Express is for IOT and highly transactional
such as IoT.</p>
<p>Started via API Gateway, IOT Rules, EventBridge, Lambda.</p>
<p>Amazon States Languate (ASL) - JSON template</p>
<p>These use IAM Roles for permissions.</p>
<h4>States</h4>
<ul>
<li>Succeed &amp; Fail : Will wait until either is achieved</li>
<li>Wait : will wait until specific date and time or period of time</li>
<li>Choice : different path is determined based on an input</li>
<li>Parallel : will create parallel branches based on a choice</li>
<li>Map : accepts a list of things</li>
<li>Task : Single unit of work (lambda, batch, dynamoDB)</li>
</ul>
<h3>Simple Queue Service (SQS)</h3>
<p>Provides managed message queues, fully managed, highly available.</p>
<p>Replication happens within a region by default.</p>
<ul>
<li>Standard :</li>
<li>FIFO queue :</li>
</ul>
<p>Messages up to 256KB in size. These should link to larger sets of data.</p>
<p>Polling is checking for any messages on the queue. When a client polls
and recieves messages, they are hidden due to <strong>visibility timeout</strong>.</p>
<p>This is the amount of time that a client can wait to work on the messages.</p>
<p>If a client recieves messages on the queue and finishes on that workload
it can delete the message. If the client doesn't delete the message, then
it will reappear on the queue. The queue will put the message back in
and make sure a different client can retry that workload.</p>
<p><strong>Dead-letter queue</strong> if a message is recieved multiple times but is unable
to be finished, this puts it into a different workload to try and fix
the corruption.</p>
<p>ASG can scale and lambdas can be invoked based on queue length.</p>
<h4>Highlights</h4>
<p>Two types of queue</p>
<p>Standard - multi-lane HW
guarantee the order and at least once delivery.</p>
<p>FIFO - single lane road with no way to overtake
guarantee the order and at exactly once delivery
3,000 messages per second with batching or up to 300 messages second without</p>
<p>Billed on <strong>requests</strong> not messages. A request is a single request to SQS
One request can send 1 - 10 messages up to 64KB total.</p>
<p>Requests can return 0 messages. The more frequently you poll a SQS Queue,
the less effective it is.</p>
<p>Two ways to poll</p>
<ul>
<li>
<p>short (immediate) : uses 1 request and can return 0 or more messages. If the
queue is empty, it will return 0 and try again. This hurts queues that stay
short</p>
</li>
<li>
<p>long (waitTimeSeconds) : it will wait for up to 20 seconds for messages
to arrive on the queue. It will sit and wait if none currently exist.</p>
</li>
</ul>
<p>Messages can live on SQS Queue for up to 15 days. They offer KMS encryption
at rest.</p>
<p>Access is based on identity policies or a queue policy.</p>
<h3>Kinesis</h3>
<p>This is a scalable streaming service. It is designed to inject data from
lots of devices or lots of applications.</p>
<p>Producers send data into a Kinesis Stream.</p>
<p>The stream can scale from low to near infinite data rates.</p>
<p>Highly available public service by design.</p>
<p>Streams store a 24-hour moving window of data. Can be increased to 7 days.
Data that is 24 hours and a second more is replaced by new data entering
the stream.</p>
<p>Kinesis includes the store within it for the amount of data
that can be ingested during a 24 hour period. However much you ingest during
24 hours, that's included.</p>
<p>Multiple consumers can access data from that moving window.
One might look at data points once per hour while another looks at data in
real time.</p>
<p>Each shard can have 1MB/s for ingestion and 2MB/s consumption.</p>
<p><strong>Kinesis data records (1MB)</strong> are stored accross shards and are the blocks
of data for a stream.</p>
<p><strong>Kinesis Firehose</strong> connects to a Kinesis stream. It can move the data
from a stream onto S3 or another service.</p>
<h3>SQS vs Kinesis</h3>
<p>Is this about the ingestion of data or is it about the worker pools.</p>
<p>Large throughput or large numbers of devices, it is likely Kinesis.</p>
<p>SQS has 1 thing sending messages to the queue. One consumption group from
that tier.</p>
<p>Allow for async communications where the sender and reciever don't care
about what the other is doing. Once the message is processed, it is deleted.</p>
<p>Kinesis is desiged for huge scale ingestion with multiple consumers. Rolling
window for multiple consumers.</p>
<p>Designed for data ingestion, analytics, monitoring, app clicks.</p>
